(function(){"use strict";var n={891:function(n,e,l){var t=l(751),r=l(641);function a(n,e,l,t,a,o){const s=(0,r.g2)("StreamChat");return(0,r.uX)(),(0,r.Wv)(s)}var o=l(33),s=l(953),i=l(23),u=l(758);const c={class:"comparison-demo"},v={class:"progress-container"},k={class:"progress-bar"},f={class:"progress-text"},d={class:"controls"},m=["disabled"],p={class:"comparison-container"},L={class:"rerender-container"},h={class:"content-box"},g={class:"streaming-container"},O={class:"content-box"},b={class:"raw-markdown"},w="# 마크다운 렌더링 방식 비교 데모\n\n 이것은 **재파싱,재렌더링 방식**과 **streaming-markdown방식**을 시뮬레이션하는 예제입니다.\n\n## 복잡한 표(Table) 렌더링 비교\n\n### 기본 표 렌더링\n\n| 방식 | 장점 | 단점 | 효율성 | 구현 난이도 |\n|------|------|------|--------|------------|\n| 재파싱·재렌더링 | 구현 간단 | 성능 저하, 깜빡임 | 낮음 | 쉬움 |\n| streaming-markdown | 부드러운 렌더링, 효율적 | 구현 복잡 | 높음 | 어려움 |\n| 하이브리드 | 균형잡힌 성능 | 추가 최적화 필요 | 중간 | 중간 |\n| 사용자 정의 렌더러 | 유연성 높음 | 개발 비용 높음 | 가변적 | 매우 어려움 |\n\n### 복잡한 중첩 표 렌더링\n\n| 상위 카테고리 | 하위 카테고리 | 세부 항목 | 설명 |\n|--------------|--------------|-----------|------|\n| 프론트엔드 | 렌더링 엔진 | **DOM 기반** | 웹 브라우저의 기본 렌더링 방식 |\n|  |  | **가상 DOM** | React, Vue 등에서 사용하는 최적화된 렌더링 |\n|  | UI 프레임워크 | *React* | 컴포넌트 기반의 선언적 UI 라이브러리 |\n|  |  | *Vue* | 점진적으로 적용 가능한 프론트엔드 프레임워크 |\n|  |  | *Angular* | 완전한 프론트엔드 솔루션 |\n| 백엔드 | 서버 | **Node.js** | 자바스크립트 런타임 환경 |\n|  |  | **Django** | 파이썬 기반 웹 프레임워크 |\n|  | 데이터베이스 | *SQL* | 관계형 데이터베이스 |\n|  |  | *NoSQL* | 비관계형 데이터베이스 |\n\n## 이미지 렌더링 비교\n\n### 단일 이미지 렌더링\n\n이미지 렌더링 마크다운 원시코드가 나오는지 관찰해보세요:\n\n![첫 번째 테스트 이미지](https://picsum.photos/400/200)\n\n### 다중 이미지 렌더링\n\n여러 이미지가 순차적으로 나타날 때의 차이점을 관찰해보세요:\n\n![두 번째 테스트 이미지](https://picsum.photos/400/150?random=1)\n\n![세 번째 테스트 이미지](https://picsum.photos/400/180?random=2)\n\n![네 번째 테스트 이미지](https://picsum.photos/400/220?random=3)\n\n## 복잡한 차트 (ASCII 아트)\n\n### 막대 차트\n```\n재파싱·재렌더링 방식 성능    [██████████████░░░░░░░░░░] 60%\nstreaming-markdown 방식 성능 [████████████████████████] 100%\n하이브리드 방식 성능         [██████████████████░░░░░░] 80%\n사용자 정의 렌더러 성능      [███████████████████░░░░░] 85%\n```\n\n\n\n## 복잡한 중첩 리스트\n\n1. 마크다운 렌더링 기본 원리\n   - 파싱 단계\n     - 토큰화(Tokenization)\n       - 마크다운 텍스트를 개별 토큰으로 분할\n       - 각 토큰은 특정 마크다운 요소를 나타냄\n     - 구문 분석(Parsing)\n       - 토큰 간의 관계 분석\n       - AST(Abstract Syntax Tree) 구성\n   - 렌더링 단계\n     - HTML 변환\n       - AST를 HTML 요소로 변환\n     - DOM 업데이트\n       - 생성된 HTML을 DOM에 삽입\n2. 재파싱·재렌더링 방식의 문제점\n   - 성능 이슈\n     - 전체 마크다운 재파싱 필요\n     - 전체 DOM 재구성 필요\n   - 사용자 경험 저하\n     > 스크롤 위치 초기화, 포커스 손실, 깜빡임 등 사용자 경험을 해치는 요소들이 발생\n     >\n     > 특히 긴 문서에서 이러한 문제가 더욱 두드러짐\n3. streaming-markdown 방식의 장점\n   - 효율적인 렌더링\n     - 증분 파싱(Incremental Parsing)\n       1. 변경된 부분만 파싱\n       2. 부분적 DOM 업데이트\n     - 메모리 효율성\n       1. 전체 문서를 메모리에 유지할 필요 없음\n       2. 낮은 메모리 사용량\n\n\n## 매우 복잡한 중첩 표 테스트\n\n| 렌더링 단계 | 재파싱·재렌더링 방식 | streaming-markdown 방식 | 비고 |\n|------------|---------------------|------------------------|------|\n| **파싱** | 매 업데이트마다 전체 파싱 | 증분 파싱 | |\n| ^^ | 시간 복잡도: O(n) | 시간 복잡도: O(1) | n: 문서 길이 |\n| ^^ | 메모리 사용: 높음 | 메모리 사용: 낮음 | |\n| **DOM 조작** | innerHTML 교체 | 부분 업데이트 | |\n| ^^ | 기존 노드 전부 폐기 | 기존 노드 유지 | |\n| ^^ | 스크롤 위치 초기화 | 스크롤 위치 유지 | |\n| **렌더링** | 브라우저 전체 리플로우 | 최소한의 리플로우 | |\n| ^^ | 깜빡임 발생 | 부드러운 전환 | |\n| **사용자 경험** | 기본 구현 간단 | 구현 복잡 | |\n| ^^ | 긴 문서에서 성능 저하 | 문서 길이에 영향 적음 | |\n| ^^ | 입력 지연 발생 | 반응성 유지 | |\n\n## 마지막 복잡한 이미지와 테이블\n\n![다섯 번째 테스트 이미지](https://picsum.photos/600/300?random=4)\n\n\n## 마무리\n\n이제 두 가지 마크다운 렌더링 방식의 차이점이 명확하게 보이시나요? 특히 복잡한 차트, 표, 이미지를 포함하는 콘텐츠에서 streaming-markdown 방식의 장점이 두드러집니다.\n\n스트리밍 방식의 차이점은 다음과 같이 요약할 수 있습니다:\n\n1. **성능 차이**: streaming-markdown 방식은 증분 업데이트를 사용하여 훨씬 효율적\n2. **사용자 경험**: 깜빡임 없이 부드러운 렌더링 제공\n3. **리소스 사용**: 메모리와 CPU 사용량이 현저히 낮음\n4. **복잡한 콘텐츠**: 표, 코드 블록, 이미지 등 복잡한 요소에서 차이가 더욱 명확\n\n이 강화된 데모를 통해 두 방식의 차이를 명확하게 비교할 수 있을 것입니다.\n";var M={__name:"StreamChat",setup(n){const e=(0,s.KR)(""),l=(0,s.KR)(null),t=(0,s.KR)(null),a=(0,s.KR)(!1),M=(0,s.KR)(0);let T=null,y=null;function C(){if(t.value){const n=u.SC(t.value);y=u.K3(n)}}function D(){if(a.value)return;if(a.value=!0,e.value="",M.value=0,T&&clearInterval(T),l.value&&(l.value.innerHTML=""),t.value){t.value.innerHTML="";const n=u.SC(t.value);y=u.K3(n)}const n=w.split(""),r=n.length;let o=0;T=setInterval((()=>{if(o<r){const t=n[o];e.value+=t,l.value&&(l.value.innerHTML=i.xI.parse(e.value)),y&&u.om(y,t),o++,M.value=Math.floor(o/r*100)}else clearInterval(T),a.value=!1,y&&u.Qp(y),console.log("스트리밍 완료!")}),35)}return(0,r.sV)((()=>{C(),D()})),(0,r.hi)((()=>{T&&clearInterval(T)})),(n,s)=>((0,r.uX)(),(0,r.CE)("div",c,[s[5]||(s[5]=(0,r.Lk)("h1",null,"마크다운 렌더링 방식 비교 - 강화 데모",-1)),s[6]||(s[6]=(0,r.Lk)("div",{class:"explanation"},[(0,r.Lk)("p",null,"이 데모는 두 가지 마크다운 렌더링 방식을 비교합니다:"),(0,r.Lk)("ul",null,[(0,r.Lk)("li",null,[(0,r.Lk)("strong",{style:{color:"#d32f2f"}},"재파싱·재렌더링 방식"),(0,r.eW)(": 매 문자마다 전체 마크다운을 재파싱하고 전체 DOM을 교체합니다.")]),(0,r.Lk)("li",null,[(0,r.Lk)("strong",{style:{color:"#1a73e8"}},"streaming-markdown 방식"),(0,r.eW)(": 부분 DOM 패치를 사용하여 변경된 부분만 업데이트합니다.")])]),(0,r.Lk)("p",null,[(0,r.Lk)("em",null,"특별히 복잡한 차트, 표, 이미지와 중첩 구조를 포함하여 두 방식의 차이를 명확히 보여줍니다.")])],-1)),(0,r.Lk)("div",v,[(0,r.Lk)("div",k,[(0,r.Lk)("div",{class:"progress-fill",style:(0,o.Tr)({width:`${M.value}%`})},null,4)]),(0,r.Lk)("div",f,(0,o.v_)(M.value)+"% 완료",1)]),(0,r.Lk)("div",d,[(0,r.Lk)("button",{onClick:D,disabled:a.value},(0,o.v_)(a.value?"스트리밍 중...":"스트리밍 시작"),9,m)]),(0,r.Lk)("div",p,[(0,r.Lk)("div",L,[s[0]||(s[0]=(0,r.Lk)("h2",null,"재파싱·재렌더링 방식",-1)),(0,r.Lk)("div",h,[(0,r.Lk)("div",{ref_key:"rerenderElement",ref:l,class:"content"},null,512)]),s[1]||(s[1]=(0,r.Lk)("div",{class:"info"},[(0,r.Lk)("ul",null,[(0,r.Lk)("li",null,"매 문자마다 전체 마크다운 재파싱"),(0,r.Lk)("li",null,"DOM 전체 교체"),(0,r.Lk)("li",null,"텍스트가 길어질수록 성능 저하"),(0,r.Lk)("li",null,"복잡한 요소에서 깜빡임 명확")])],-1))]),(0,r.Lk)("div",g,[s[2]||(s[2]=(0,r.Lk)("h2",null,"streaming-markdown 방식",-1)),(0,r.Lk)("div",O,[(0,r.Lk)("div",{ref_key:"streamingElement",ref:t,class:"content"},null,512)]),s[3]||(s[3]=(0,r.Lk)("div",{class:"info"},[(0,r.Lk)("ul",null,[(0,r.Lk)("li",null,"부분적 DOM 패치 적용"),(0,r.Lk)("li",null,"변경된 부분만 업데이트"),(0,r.Lk)("li",null,"효율적인 메모리 및 CPU 사용"),(0,r.Lk)("li",null,"복잡한 요소도 부드럽게 렌더링")])],-1))])]),(0,r.Lk)("div",b,[s[4]||(s[4]=(0,r.Lk)("h3",null,"원시 마크다운 (현재 스트리밍 진행 상태):",-1)),(0,r.Lk)("pre",null,(0,o.v_)(e.value),1)])]))}},T=l(262);const y=(0,T.A)(M,[["__scopeId","data-v-f88c2512"]]);var C=y,D={name:"App",components:{StreamChat:C}};const I=(0,T.A)(D,[["render",a]]);var S=I;(0,t.Ef)(S).mount("#app")}},e={};function l(t){var r=e[t];if(void 0!==r)return r.exports;var a=e[t]={exports:{}};return n[t](a,a.exports,l),a.exports}l.m=n,function(){var n=[];l.O=function(e,t,r,a){if(!t){var o=1/0;for(c=0;c<n.length;c++){t=n[c][0],r=n[c][1],a=n[c][2];for(var s=!0,i=0;i<t.length;i++)(!1&a||o>=a)&&Object.keys(l.O).every((function(n){return l.O[n](t[i])}))?t.splice(i--,1):(s=!1,a<o&&(o=a));if(s){n.splice(c--,1);var u=r();void 0!==u&&(e=u)}}return e}a=a||0;for(var c=n.length;c>0&&n[c-1][2]>a;c--)n[c]=n[c-1];n[c]=[t,r,a]}}(),function(){l.d=function(n,e){for(var t in e)l.o(e,t)&&!l.o(n,t)&&Object.defineProperty(n,t,{enumerable:!0,get:e[t]})}}(),function(){l.g=function(){if("object"===typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(n){if("object"===typeof window)return window}}()}(),function(){l.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)}}(),function(){var n={524:0};l.O.j=function(e){return 0===n[e]};var e=function(e,t){var r,a,o=t[0],s=t[1],i=t[2],u=0;if(o.some((function(e){return 0!==n[e]}))){for(r in s)l.o(s,r)&&(l.m[r]=s[r]);if(i)var c=i(l)}for(e&&e(t);u<o.length;u++)a=o[u],l.o(n,a)&&n[a]&&n[a][0](),n[a]=0;return l.O(c)},t=self["webpackChunkstream_test"]=self["webpackChunkstream_test"]||[];t.forEach(e.bind(null,0)),t.push=e.bind(null,t.push.bind(t))}();var t=l.O(void 0,[504],(function(){return l(891)}));t=l.O(t)})();
//# sourceMappingURL=app.0273eab1.js.map